% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/solve.nonogram.R
\name{solve.nonogram}
\alias{solve.nonogram}
\title{solve.nonogram}
\usage{
\method{solve}{nonogram}(
  nonogram,
  algorithm = "perm_elim",
  row_permutations = NULL,
  column_permutations = NULL,
  verbose = TRUE,
  max_iter = 100
)
}
\arguments{
\item{nonogram}{An object of class nonogram.}

\item{algorithm}{Algorithm used to solve the nonogram. Argument not currently
used as only \code{"perm_elim"} algorithm is implemented.}

\item{row_permutations}{A matrix with the same number of columns as there are
rows in the nonogram, and whose rows represent every possible permutation
of 0s and 1s for the number of rows in the nonogram. Default = \code{NULL}.}

\item{column_permutations}{A matrix with the same number of columns as there are
columns in the nonogram, and whose rows represent every possible permutation
of 0s and 1s for the number of columns in the nonogram. Default = \code{NULL}.}

\item{verbose}{If \code{TRUE} (the default), prints progress messages to the console.}

\item{max_iter}{Maximum number of iterations allowed by the solver.}
}
\value{
A solved nonogram containing the found solution.
}
\description{
Given a valid nonogram object, will attempt to find a solution
that satisfies the row and column patterns.
}
\details{
The permutation elimination algorithm follows the following process:
\enumerate{
\item{For a nonogram with m rows and n columns, if m = n then generate
a single matrix with n columns whose rows represent every possible
permutation of 0s and 1s for a vector of length n. If m != n then
generate two matrices, one containing all possible row permutations
and one containing all possible column permutations.}
\item{Convert each permutation from the full permutation matrix/matrices
into its run length-encoded form. E.g. 000110111101 would become
241 in run length encoding.}
\item{For each row and column of the nonogram, find every permutation in
the full permutation matrix appropriate for that dimension, whose rows
have the same run length encoding as the nonogram's row/column in question.
Set these permutations as the initial solution set for that row/column.
Repeat this process until every row and column has an initial solution set.}
\item{For each row and column of the nonogram, identify any elements across
the solution set that are all 0 or all 1 for all possible permutations.
E.g. if all permutations for column j have a 0 at element k, then eliminate
any solutions in row k that don't have a 0 at element j. Perform this
action for every row and column. A single iteration has passed once
this has been applied to every row and column once.}
\item{Repeat step 4 until only a single solution remains for every row and
column. Return the nonogram with the solution.}
}\preformatted{If the `row_permutations` or `column_permutations` arguments are `NULL`, the 
full permutation sets will first be generated by calling `make_full_perm_set()`
using the appropriate dimension from the nonogram object. If solving multiple
nonograms with the same dimensions, it will be faster to computer the full
permutation sets first, and pass these to the `row_permutations` and
`column_permutations` arguments.

If `verbose = TRUE` then progress text will be printed to the console. Once
the algorithm begins "Eliminating non-viable permutations", the number of
possible remaining solutions for each column and row will be printed for each
iteration. Only once all the values are 1, has a final solution been converged
upon.

The permutation elimination algorithm will fail to converge on a solution
if the nonogram has a regular checkerboard pattern.
}
}
\examples{
# Without pre-defining full permutation matrices
f <- examples[[31]]
f <- solve(f)

# With pre-defined full permutation matrices
full_perms <- make_full_perm_set(15)
f <- solve(f, row_permutations = full_perms, column_permutations = full_perms)

}
